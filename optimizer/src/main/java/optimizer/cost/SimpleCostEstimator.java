package optimizer.cost;

import core.parser.dictionary.Dictionary;
import core.structs.Tuple;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class SimpleCostEstimator implements CostEstimator {
    private final Map<String, Set<String>> operatorParents;
    private final Dictionary dictionary;
    private final Map<String, String> classKeyMapping;
    private final String statisticsDir;

    public SimpleCostEstimator(Map<String, Set<String>> operatorParents,
                               Dictionary newDictionary,
                               Map<String, String> classKeyMapping,
                               String statisticsDir) {
        this.operatorParents = operatorParents;
        this.dictionary = newDictionary;
        this.classKeyMapping = classKeyMapping;
        this.statisticsDir = statisticsDir;
    }

    /**
     * Method to generate a unique hash for each flow
     * The hash is generated by updating a SHA-1 hash with the operator name and site name of each vertex
     * @return SHA-1 hash of the mapping
     */
    public String getUniqueHash(LinkedHashMap<String, Tuple<String, String>> operatorImplementations) {
        List<String> operatorNames =  new ArrayList<>(operatorImplementations.keySet());
        Collections.sort(operatorNames);

        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            for (String operatorName : operatorNames) {
                Tuple<String, String> implementation = operatorImplementations.get(operatorName);
                String siteName = implementation._1;
                md.update(operatorName.getBytes());
                md.update(siteName.getBytes());
            }

            byte[] digest = md.digest();
            StringBuilder sb = new StringBuilder();

            for (byte b : digest) {
                sb.append(String.format("%02x", b));
            }

            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    public int getPlanTotalCost(LinkedHashMap<String, Tuple<String, String>> operatorImplementations) {
        return 0;
    }

//    public int getPlanTotalCost(LinkedHashMap<String, Tuple<String, String>> operatorImplementations) {
//        String hash = getUniqueHash(operatorImplementations);
//        String filename = statisticsDir + File.separator + hash + ".json";
//        try (FileReader fileReader = new FileReader(filename);) {
//            Gson gson = new Gson();
//            iFogSimMetrics metrics = gson.fromJson(fileReader, iFogSimMetrics.class);
//            System.out.println(metrics.getAppLoopLatency());
//        } catch (IOException e) {
//            return Integer.MAX_VALUE;
//        }
//        return 8000;
//    }




//    public int getPlanTotalCost(LinkedHashMap<String, Tuple<String, String>> operatorImplementations) {
//        int cost = 0;
//
//        for (String op : operatorImplementations.keySet()) {
//            String classKey = classKeyMapping.get(op);
//            if (classKey == null) {
//                //Handle unknown operators
//                continue;
//            }
//            String curSite = operatorImplementations.get(op)._1;
//            String curPlatform = operatorImplementations.get(op)._2;
//
//            int siteMigrationCost = 0;
//            int platformMigrationCost = 0;
//
//            for (String parent : this.operatorParents.getOrDefault(op, Collections.emptySet())) {
//                String parentSite = operatorImplementations.get(parent)._1;
//                String parentPlatform = operatorImplementations.get(parent)._2;
//                siteMigrationCost = Math.max(siteMigrationCost, this.dictionary.getSiteMigrationCostForClassKey(classKey, parentSite, curSite));
//                platformMigrationCost = Math.max(platformMigrationCost, this.dictionary.getPlatformMigrationCostForClassKey(classKey, parentPlatform, curPlatform));
//            }
//
//            cost += this.dictionary.getOperatorCost(classKey);
//            cost += this.dictionary.getSiteStaticCostForClassKey(classKey, curSite);
//            cost += this.dictionary.getPlatformStaticCostForClassKey(classKey, curPlatform);
//            cost += siteMigrationCost;
//            cost += platformMigrationCost;
//        }
//        return cost;
//    }

    //Platform related costs (static and migration)
    public int getPlanPlatformCost(LinkedHashMap<String, Tuple<String, String>> operatorImplementations) {
        int cost = 0;
        for (String op : operatorImplementations.keySet()) {
            String classKey = classKeyMapping.get(op);
            if (classKey == null) {
                continue;
            }
            String curPlatform = operatorImplementations.get(op)._2;
            int platformMigrationCost = 0;
            for (String parent : this.operatorParents.getOrDefault(op, Collections.emptySet())) {
                String parentPlatform = operatorImplementations.get(parent)._2;
                platformMigrationCost = Math.max(platformMigrationCost, this.dictionary.getPlatformMigrationCostForClassKey(classKey, parentPlatform, curPlatform));
            }
            cost += this.dictionary.getPlatformStaticCostForClassKey(classKey, curPlatform);
            cost += platformMigrationCost;
        }
        return cost;
    }

    //Static cost of an operator and its implementation
    public int getOperatorAndImplementationCost(String operator, Tuple<String, String> implementation) {
        int cost = 0;
        String classKey = this.classKeyMapping.get(operator);
        if (classKey == null) {
            return 0;
        }
        cost += this.dictionary.getOperatorCost(classKey);
        cost += this.dictionary.getSiteStaticCostForClassKey(classKey, implementation._1);
        cost += this.dictionary.getPlatformStaticCostForClassKey(classKey, implementation._2);
        return cost;
    }

    //Site and platform migration between two implementations
    public int getMigrationCost(String op1, Tuple<String, String> impl1, Tuple<String, String> impl2) {
        int cost = 0;
        String classKey1 = this.classKeyMapping.get(op1);
        if (classKey1 == null) {
            return 0;
        }
        cost += this.dictionary.getSiteMigrationCostForClassKey(classKey1, impl1._1, impl2._1);
        cost += this.dictionary.getPlatformMigrationCostForClassKey(classKey1, impl1._2, impl2._2);
        return cost;
    }

    public int getHeuristicCostForOperator(String operator) {
        String key = classKeyMapping.get(operator);
        if (key == null) {
            return 0;
        }
        return this.dictionary.getOperatorCost(key)
                + this.dictionary.getMinSiteCostForOperator(key)
                + this.dictionary.getMinPlatformCostForOperator(key)
                + this.dictionary.getMinPlatformCostMigrationForOperator(key)
                + this.dictionary.getMinSiteCostMigrationForOperator(key);
    }
}

